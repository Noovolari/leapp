# What should I know before I get started?

If you want to start a code contribution to Leapp, whether it is a bug fix or a new feature, it is important for you to understand Leapp concepts and way to work.

In the documentation site you’ll find all the information you need. [Leapp documentation](http://docs.leapp.cloud) covers the following concepts and topics:

- Sessions
- Integrations
- Security
    - Short-term credentials generation
    - System Vault for storing sensitive information (e.g. AWS IAM User access keys)
- Built-in features
    - EC2 connect through AWS SSM
    - AWS Multi-profile management

# Development environment setup

## Node.js and NPM

Follow [this](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm) official guide to install both Node.js and NPM.

The latest build was released using Node.js version 14.17.0 - as specified in the .nvmrc - and NPM version 8.3.0.

## NVM

[Here](https://github.com/nvm-sh/nvm#installing-and-updating) you can find the official installation guide.

## Git

[Here](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) you can find the official installation guide.

## Fork and clone through GitHub CLI

Follow [this](https://github.com/cli/cli#installation) guide to install the GitHub CLI.

Log into GitHub (e.g. using your GitHub personal access token) using the following command:

```bash
gh auth login
```

Once logged in, you can fork and clone the repository with the following command:

```bash
gh repo fork noovolari/leapp
```

## Fork and clone manually

If it is the first time you fork a repository from the GitHub console, please refer to [this](https://docs.github.com/en/get-started/quickstart/fork-a-repo) guide.

## Syncing a fork

[This](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/syncing-a-fork) guide explains you how to keep your local branch up-to-date with the upstream one.

## Install dependencies

Inside the project root folder, run 

```bash
nvm use
```

to set the Node.js version to the one specified in the .nvmrc; then, run

```bash
npm install
```

to install all the dependencies specified in the package.json file.

## System Vault

Skip this section if you are not using a Linux system. 

Leapp relies on the System Vault to save sensitive information. In Linux systems it relies on libsecret and gnome-keyring dependencies. To install them, follow [this](https://docs.leapp.cloud/latest/installation/requirements/) documentation page.

## AWS CLI

[Here](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html) you can find the official installation guide.

## AWS SSM

To install the AWS SSM agent locally, follow [this](https://docs.leapp.cloud/latest/installation/requirements/) documentation page.

## Azure CLI

[Here](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli) you can find the official installation guide.

# Project Structure

Leapp is an application built using Electron and Angular. The first is used in order to generate executables for different OSs: macOS, Windows, and Linux distros. It serves as a wrapper for the Angular site which hosts the application logic, by serving it through a combination of [Chromium](https://www.chromium.org/Home/) and Node.js.

If you are new to Electron, please refer to the official [documentation](https://www.electronjs.org/docs/latest).

Angular is a front-end web development framework for creating efficient and sophisticated single-page apps via HTML, Typescript, and modern SCSS. 

If you are new to Angular, why not try the excellent **tour of heroes** [sample project](https://angular.io/tutorial) to get you started?

After you got yourself acquainted with our development tools, let’s dig into our code structure.

## Monorepo

To facilitate and keep track of contributions, we will approach a monorepo architecture; it allows maintaining different projects under the same repository. The current repository is not yet organized in a monorepo fashion. It will be introduced with Leapp Core and CLI. The Core will contain the application logic; basically, it will act as a library on top of which clients, like the Desktop Application and the CLI, will run. In the monorepo scenario, Desktop Application, CLI, and Core will be three different projects under the same repository.

## Electron project elements

There is an **electron** folder generated by Electron at the root of the repository. It contains the **main.ts** file which drives the application setup and starts the executable by injecting the Angular application into the main BrowserWindow. This is created after the Angular project has been set up, cleaned, compressed, and distributed as a minimized site.

## Angular project elements

The Angular project is wrapped in the Electron one and implements the logic behind each Leapp concept. Let’s dive into the Angular project, from the UX/UI elements to the low level ones, i.e. Models and Services. 

### Modules

Modules are elements in an Angular project that allows using different components that are defined in the same functional scope. In Leapp we have **3 modules**.

- **app.module.ts**: contains all the **global libraries ad components.** Here you can put all the external libraries that you need.
- **layout.module.ts**: is specific for the layout component, and contains only information that is used in the layout.component.ts file. It is called inside the app module.
- **components.module.ts**: is the module responsible for holding all the components of the application. It is called inside the app module.

There is also one super simple **app.routing.module**, which contains only one route pointing to the layout which contains our **3 main components**: **sidebar**, **command-bar**, **and sessions**.

### Components

Inside the Component folder, there are all the different components of the applications, which are composed of a UI file in the form of an HTML template, a SCSS file, that contains the style, and finally, 2 TypeScript files: <component>.ts for the logic, and <component>.spec.ts for the unit tests.

Components represent core UI/UX functionalities. If you intend to define a new functionality that must have its UI counterpart, please insert the new component here. 

There is also a dialogs folder that contains, for easiness, all the dialog components of Leapp. 

For us, it is best to create a new component every time we need a new dialog in the interface, just to keep things well separated and DRY.

### Models

The Models folder contains TypeScript interfaces that represents the state of Leapp, that is persisted in Leapp’s configuration file, and other interfaces that needs to be centralized and used across different logic inside the Angular project.

For what concerns the state of the application, you’ll find a definition of all the supported Sessions and a Workspace object which represents the template of the configuration file.

The Workspace includes:

- a list of all the created Sessions;
- the default region and location (region for AWS, location for Azure);
- the IdP URLs the IAM Role Federated Sessions rely on;
- the AWS Named Profiles;
- the AWS SSO Integrations;
- all the Segments created by the user to filter out Sessions while using the desktop application.

For what concerns Sessions, all models share some basic information, common to all of them. These variables must always be defined.

```
...
export class Session {

  sessionId: string;
  sessionName: string;
  status: SessionStatus;
  startDateTime: string;
  region: string;
  type: SessionType;

  ...
}

```

| Session Variable| Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ---------------- |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `sessionId`      | A **Unique identifier** for the Session. It is defined at Model instantiation, and represents a unique ID for the session. Every operation involving a specific session must start by getting a session through its `sessionId`                                                                                                                                                                                                                                                |
| `sessionName`    | A **fancy name**, chosen by the user when creating the Session, to make it recognizable at first glance.                                                                                                                                                                                                                                                                                                                                                                       |
| `status`         | Represents the **State Management** of a single session; when the **status** of a session is `active`, temporary credentials are available to the user. The possible values are: `inactive`, `pending`, `active`                                                                                                                                                                                                                                                               |
| `startDateTime`  | A **UTC DateTime** string representing the last time a specific Session has started; this is useful for rotation and sorting purposes                                                                                                                                                                                                                                                                                                                                          |
| `region`         | The **AWS Region** or **Azure Location** the Session is working on. For a complete list of AWS Regions go [here](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html), and for Azure Locations, go [here](https://azure.microsoft.com/it-it/global-infrastructure/data-residency/#overview)                                                                                                                                       |
| `type`           | Uniquely identifies two important aspects to determine the Session: **Cloud Provider** and **Access Method.**. Possible values are: `awsIamRoleFederated`, `awsIamUser`, `awsIamRoleChained`, `awsSsoRole`, `azure`. The naming convention we are using is *cloudProvider-accessMethod*: **Cloud Provider** on which you are connecting (i.e., AWS, Azure, GCP...), and the **Access Method** used to generate credentials (i.e., AWS IAM User, Azure Tenant, AWS IAM Role...) |

### Services

Leapp's project is built on a set of **services** that realize the **core functionalities**.

The actual project's structure is structured to allow developers to contribute to source code in the easier and atomic way possible.

In particular, we want to focus the attention on the development of Session Service Patterns and Integrations.

<br>

**Session Service Pattern**

A specific service manages the way each type of Session will handle the process of credentials generation.

![](docs/images/contributing/project_structure/PROJECT_STRUCTURE-1.png)

There is a **three-level abstraction** implementation for this kind of service:

- A general **Session Service** is the top level of abstraction of a Session, it implements the state management of any Session in the app and has three abstract methods for Start, Stop, and Rotate.
- A **Provider Session Service** (i.e., *AWSSessionService*) extends the general session service and handles credentials for a specific Cloud Provider to Start, Stop, and Rotate each Session of this type. This level of abstraction unifies all the common actions for all the Access Methods within a Cloud Provider.
- A **Provider Access Method Service** (i.e., *AWSIAMUserService*) is the concrete implementation of all the information needed to generate the credentials for a specific Access Method. It implements both CRUD methods and the specific steps to generate credentials for a given Access Method.

<br>

**Integrations**

To understand this concept, let’s dive into what the AWS SSO feature does. 

In Leapp you can work with Sessions that corresponds to AWS accounts that belong to one or more AWS Organizations. By configuring AWS SSO in the root account (or another dedicated account), you're able to manage access to all of the AWS Organization’s accounts. 

AWS SSO configuration is bound to a specific region (e.g. eu-west-1, etc.) and portal URL. The last one corresponds to the endpoint used to log into AWS SSO. By logging into AWS SSO through the AWS SDK, you have access to a token that can be used to list all the accounts and roles that can be accessed by the user. AWS SSO API allows you to automatically generate temporary credentials to access accounts with a specific role. Once you’re done, you can log out from AWS SSO.

From this behaviour we extrapulated the concept of Integration that can be applied to other third-party services like - for example - Okta and OneLogin.

The concept of Integration encapsulates the following behaviours:

- login - logging into the Integration and get an access token to exploit its APIs;
- sync - automatically provision all the accounts and roles that can be access by the user through the access token;
- logout - logging out from the Integration.

### Errors

These folder contains Leapp standard errors, from the less specific LeappBaseError to the more specific ones. The specific errors extend LeappBaseError, inheriting attributes like name, context, and severity.

### Environments

Here you’ll find project’s constants that will be merged soon into the Constants model to avoid misunderstandings. We’ll leave here only information related to the environment the application is running in, e.g. development or production.

# Build

The package.json file contains all the build scripts, in addition to the dependencies and other project’s metadata. You can find this file in the root of the project.

All the scripts are grouped under the “scripts” key. There you can find the “build-and-run-dev” script that you can use to build and run the Electron application locally.

If Electron is failing building the native Library `Keytar` just run the following command, before `npm run build-and-run-dev`:

```bash
# Clear Electron and Keytar conflicts
npm run rebuild-keytar
```

# Troubleshooting

To troubleshoot the electron application in the development environment, please refer to [this](https://docs.leapp.cloud/latest/troubleshooting/app-data/) documentation page. Moreover, you may find it useful to open the Developer Tools from the Electron’s BrowserWindow that hosts the Angular application.

# Editor preferences

Editor preferences are available in the [editor config](.editorconfig) for easy use in
common text editors. Read more and download plugins at [editorconfig.org](http://editorconfig.org).

# Linting

We are using [eslint](https://eslint.org/) as our project’s linter. its configuration is defined in the .eslintrc.json file, present in the project’s root folder. There you can find all style rules that apply to the code.

# Conventional Commits and Pull Request

Please refer to the [CONTRIBUTING.md](CONTRIBUTING.md) document.
